#imports
import sys
import PyQt5.QtWidgets
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QGridLayout, QPushButton
from PyQt5.QtGui import QColor



class Board(QMainWindow):
    
    def __init__(self, m=5, n=5, k=4):  #initialisieren vom spielfeld
        super().__init__()
        
        self.m = m    #row
        self.n = n    #col
        self.k = k 
    
        
    
    #ERSTELLUNG DES SPIELBRETTES            beliz
    def display(self, game):

        #titel
        self.setWindowTitle("4 Gewinnt")
        
        
        #plazieren und formatieren des fensters
        self.setGeometry(100, 100, 400, 400)
        
        
        #farbe der Kästchen
        black_color = QColor("black")
        
        #formatieren der Kästchen
        button_width = 80  # Breite jedes Kästchens
        button_height = 80  # Höhe jedes Kästchens
        
        
        #zentrales widget erstellen
        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)
        
        #QGridLayout erstellen
        self.layout = QGridLayout(self.central_widget)


        #erstellen der Kästchen
        self.buttons = []
        
        for row in range(self.m):
            row_buttons = []
            for col in range(self.n):
                button = QPushButton()                                                  #neue Instanz einer QPushButton erstellen
                button.setStyleSheet(f"background-color: {black_color.name()}")         #Kästchenfarbe
                button.clicked.connect(lambda _, r=row, c=col: game.place_symbol(r, c)) #methode zum klicken + methode place_symbol aus Game
                button.setFixedSize(button_width, button_height)                        #Grösse der Kästchens
                row_buttons.append(button)                                              #row_buttons-Liste wird ergänzt
                self.layout.addWidget(button, row, col)                                 #Gitterlayout wird ergänzt
            self.buttons.append(row_buttons)                                            #buttons wird ergänzt


class Player:                                  #jule
    def __init__(self, name, symbol):
        self.name = name
        self.symbol = symbol   
        
        
        
class ZufallsKI(Player):
    pass

class EinfacheKI(Player):
    pass

class KomplexeKI(Player):
    pass



    
class Game:                                    
    def __init__(self, m, n, k, player1, player2):                                    
        self.player1 = player1
        self.player2 = player2
        self.current_player = self.player1  # Start mit Spieler 1
        self.board = Board(m, n, k)  #Initialisierung von self.board
        self.board.display(self)     #Übergeben des 'self'-Objekts an die display-Methode
        
        
    #RUFT SYMBOL AUF SPIELFELD AB UM ZU SCHAUEN WELCHES SYMBOL AN DIESER STELLE IST    anne
    def get_symbol(self, row, col):                  
        button = self.board.buttons[row][col]
        return button.text()


    #PLATZIEREN DER SYMBOLE                  anne, beliz   
    def place_symbol(self, row, col): 
        if self.get_symbol(row, col) == "":          #prüft ob das Kästchen leer ist
            
            #entscheiden wer dran ist und das jeweilige Symbol wählen
            self.board.buttons[row][col].setText(self.current_player.symbol)
            
            #überprüfung: Spielende?
            winner = self.check_winner()
            #ausgabe gewinner (falls vorhanden)
            if winner:
                print(f"{self.current_player.name} wins!")
                self.board.close()  #Schließt das Fenster
            #gleichstand
            elif self.is_board_full() == True:
                print("No one winns")
                self.board.close()  #Schließt das Fenster
            
            #spielerwechsel (falls kein gewinner/gleichstand vorhanden)
            self.current_player = self.player1 if self.current_player == self.player2 else self.player2
            
            
    #GEWINNÜBERPRÜFUNG                       anne
    def check_winner(self):                  
      for i in range(self.board.m):
        for r in range(self.board.n):
          symbol = self.get_symbol(i, r)
          if symbol != "":
            #horizontal
            if r + self.board.k <= self.board.n and all(self.get_symbol(i, r + c) == symbol for c in range(self.board.k)):
              return symbol
            #vertikal
            if i + self.board.k <= self.board.m and all(self.get_symbol(i + c, r) == symbol for c in range(self.board.k)):
              return symbol
            #diagonal \
            if r + self.board.k <= self.board.n and i + self.board.k < self.board.m and all(self.get_symbol(i +c, r + c) == symbol for c in range(self.board.k)):
              return symbol
            #diagonal /
            if r - self.board.k >= -1 and i + self.board.k <= self.board.m and all(self.get_symbol(i +c, r - c) == symbol for c in range(self.board.k)):
              return symbol
      return None
        
  
    
    #UEBERPRUEFT AUF GLEICHSTAND             beliz
    def is_board_full(self):               
        #schleifen durch das Spielfeld
        for row in range(self.board.m):
            for col in range(self.board.n):
                #Ueberpruefen jeder Zeile, ob voll oder leer
                button = self.board.buttons[row][col]
                if button.text() == "":
                    return False          #brett nicht voll
        return True                       #brett voll -> unentschieden 
    





#ausführen 
    
if __name__ == "__main__":
    app = QApplication(sys.argv)


    player1 = Player("Max", "x")
    player2 = Player("Tom", "o")

    game = Game(5, 5, 4, player1, player2)
    game.board.show()
    sys.exit(app.exec_())



